# 変数は型あり。データは型なし。

## 表の顔と裏のバイト列

>「でも、0と1の羅列ってイメージが難しいですね」

そうだね。だから、Cプログラマは実際には数字をまとめて扱う。
Cプログラマの頭の中には0と1があるのではなく、
方眼紙のひとマスひとマスに、0から255までの数字がはいっているところが
イメージされている。0から255まで数字は8ビット、つまり0か1の8桁で
表される。0から255の数字は16進数で書けば2桁だから、こんな感じだ

![8ビットつまり1バイトの数字がはいる方眼紙](./memory_map.png)

実際には0101010と0と1が並んでいるんだけども、
それを人間の方で勝手に8つずつに区切っているわけだ。
まあ慣れたプログラマなら16進数を2進数に直すのはすぐだし。
全部覚えちゃってるからね。

>「え！？256種類全部覚えているんですか？」

いや、覚えるのは16種類でいいじゃない。出てくる文字は0からfまでの16個なんだから。

>「あ、そうか。それでも覚えるのは大変じゃないですか？」

別に覚えなくてもいいよ。すぐに求められるんだから。
例えば、b(2進数の11)だったら8 * 1 + 4 * 0 + 2 * 1 + 1 * 1 = 1011は
すぐに頭の中だけで求められるだろう？
だったら0x6bが01101011なのもすぐわかるだろう。逆にこれが10進数でいくつかと
聞かれると6 * 16 + 11 は暗算が難しいよね。
なので、10進数はメモリを表現するのにはあんまり使わない。

そして、実はC言語もこの8ビットの単位ごとの箱に番号をつけて管理する。
というのも、メモリは1ビットずつ読むわけではなくて、
ある程度まとめて読むからだ。ご想像の通り、32bit CPUは32ビットずつ読む。
で、8ビットより細かい単位で読むマシンの事は考えなくてもよかろうと
C言語を作った時点でなったんだろうね。あまりよく知らないけど。

というわけで、この8ビット単位の箱に番号つまりアドレスが付くんだ。

では、実際にメモリにアドレスをが付いている様子を見てみよう。
次のプログラムをコンパイルして、実行してみよう。
何が書いてあるのかは理解できなくてもいい。
ただ、printfが何かを表示する命令で、それ以外は代入と足し算しかないんだから、
まったく理解できないって感じでもないだろう。

```c
#include <stdio.h>

int main(int argc, char** argv){
  char *str = "thanks";
  
  printf("ADDRESS: %p\n", &str);
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);

  str = str + 4;

  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
}
```

実行結果はこんな感じだ。

~~~
ADDRESS: 0x7ffeea072a58
ADDRESS: 0x105b8df92
VALUE: 74
ADDRESS: 0x105b8df96
VALUE: 6b
~~~

>「うわっ！なんじゃこりゃ！」

なんのことかさっぱりわからないと思うけど、ゆっくり説明するから
心配しなくていい。

先に、メモリマップを出しておこうか。
このプログラムを実行すると、ある時点でメモリの内容は
こんな感じになっている。

![メモリマップ](./address.png)

広大なメモリのうち、上の段の6バイト、下の段の8バイト、
合わせて14バイトに何が入っているのかを表したものだ。
上の段と下の段は、メモリのある2カ所を取り出している。
1つは0x105b8df92付近。もうひとつは0x7ffeea072a58付近。
両者はかなり桁が違うので、メモリ上のかなり離れた位置に
あるってことになる。

> 「このアドレスの値は、たまたまこの値なだけで
> 私のPCで実行したら変わっちゃうんですよね？」

その通り。というか、何度も実行したらそのたびに違うかも知れない。
そういうものだ。さて、順番に見ていこうか。

まず、プログラム自体を見る前に、
C言語特有の演算子を説明しよう。なんと、いきなりポインタの話だ。

2つの演算子が登場する。1つは`&`。もうひとつは`*`だ。
`&`を「アドレス演算子」、`*`を「間接演算子」と呼ぶよ。

`&`を変数に付けると、その変数のメモリ上の位置、つまりアドレスが
取得できる。`*`はその逆演算だ。変数に`*`を付けるとその変数の値を
アドレスだとみて、そのアドレスが指す位置に格納されているデータを取り出す。
これは実例を見ればさほどややこしくはないと思う。
演算子の話はこれで終わりだ。

早速、プログラムの最初から見ていこう。

1行目はprintf()を使うために必要になるおまじないだ。
Javaのimportと同じだと思っていい。

3行目はmain関数の定義だ。ここもJavaとよく似ているよね。
C言語で書いたプログラムは、main関数から実行される約束になっている。

では、main関数の中身にいこう。

ここで、新しい`*`の使い方がでてくる。
この`*`はさっきの間接演算子と関係はあるが、別物だ。
アドレスを格納する変数を宣言するときにも`*`を使うんだ。
演算子はそんなにややこしくはないけど、こっちが概念的になかなかややこしい。
main関数の最初の部分を見てみよう。

```c
char *str = "thanks";
```

これは何をやっているのかというと、「char型のポインタstrを宣言して、
そこに文字列のアドレスを格納している」という言い方になる。
いよいよポインタという言葉がでてきたね。
つまり、ポインタとは「アドレスを格納するため変数」だ。

では、char型のポインタとはどういう意味だろう。

char型というのは、(英数字)1文字を格納するための整数型だ。
英語圏の人はたかだかアルファベットと数字といくつかの記号しか
文字が必要じゃなかったので、1文字を8ビットの整数で表すことにした。
日本語のことなんか、これっぽっちも考えてなかった時代に作られてるからね。

char型の変数に`&`をつけると、アドレスが得られる。
私のPCは64bitなので、実体は8バイトの整数だ。
例えば、32ビットの整数型であるint型の変数に`&`をつけても、
同じように8バイトの整数としてアドレスが得られる。

そのアドレスに対して`*`を適用して元の値を取り出すときに、
もともとchar型だったのか、int型だったのかわからないと困ってしまう。
charなら1バイトの箱1つ読めばいいが、
intなら32ビットだから4つ読まないといけない。
だから、ポインタはもともとどんな型のデータのアドレスだったかを
維持しておく必要がある。
だから、「char型のポインタ」というものが必要になるんだ。

そして、その宣言の書き方なんだけど、`char *str`と書くと、
`*`演算子が値をアドレスだと思って
そのアドレスの値を取り出す演算子なんだから、
「strは`*`を付けるとcharになる変数」という意味になる。
つまり、`str`はchar型のポインタということだ。
けして、「`*str`」という変数を宣言しようとしているわけではない。
回りくどいね。

さらにややこしいことに、`char* str`と書くことも出来る。
これだと`char*`で「char型のポインタ」という型の様に見えるので、
こっちを好む人も多い。
実は`char * str`でもエラーにならないんだけど、これだと
掛け算みたいで訳がわからないので、こう書く人は見たことがない。

> 「え、どっちでもいいんですか？」

最初に書いた`char *str`の書き方をオススメしておくよ。
ただ、`char* str`と書くのも多く見かけるので、驚かないように。

さて、

```c
char *str = "thanks";
```

と書かれた1行に対して、C言語は何を行うのか見ていこう。

まず、メモリ内に"thanks"という文字列に当たるバイト列を
書き込む。これは0x7468616e6b73という並びになる。
ASCIIコード表を見て確認してみてくれ。
これがメモリのどこかに書き込まれるわけだ。
代入の右側に文字列リテラルを書くと、
その文字列を書き込んだメモリのアドレスが代入の左側に渡る。

次に、そのアドレスを格納するための変数strのために
メモリを確保する。アドレスは8バイトだからメモリのどこかに
8バイトの空きを見つけて、そこを「ここはstrが使うからね」と
閻魔帳にメモっておく。
そして、そこに"thanks"が書かれた場所のアドレスを
保存する。

これで、さっき見せたメモリの状態になるんだ。
もう一度見ておこうか。

![メモリマップ](./address.png)

アドレス0x105b8df92に0x74が格納されている。
これは"thanks"の最初の"t"だ。そこから順に"thanks"が保存されているね。

そして、0x7ffeea072a58から8バイト続けて
0x92dfb80501000000が保存されている。
これは実は"thanks"を格納した場所のアドレス0x105b8df92が
バイトごとに逆さまに入っているんだ。わかるかな？

> 「92, df, b8・・・はい、なるほど。ビット列が逆なのではなくて、
> バイトの単位にした上で逆の並び方なんですね。でもなんで逆？」

それはそういう風にIntelのCPUが作られたからとしか言い様がないな
^[このような並べ方をリトルエンディアンという]。
理由はあるんだろうけど、別にどっち向きに格納していても
使う上で問題は無いんだ。今はそういうものだと思っていてくれ。

というわけで、変数宣言して文字列リテラルを代入しただけだけど、
1行で結構いろいろとやったもんだ。

プログラムの次の部分を見ていこう。

```c
  printf("ADDRESS: %p\n", &str);
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
```

対応する実行結果はこうだった

~~~
ADDRESS: 0x7ffeea072a58
ADDRESS: 0x105b8df92
VALUE: 74
~~~

printfは、変数をいろんなフォーマットで表示する関数で、
C言語の入門書の一番最初のページに書いてあるような関数だけど、
実はものすごく奥が深い関数だ。ま、おいおい知ってくれたらいい。

表示形式に%pを指定すると、2つ目の引数をポインタだと解釈して、
16進数で表示してくれる。
最初は&str、つまり"thanks"のアドレスを保存しているポインタのアドレスを
表示している。さっきのメモリマップの下の段の方だ。

そして、次にstrの中身、つまり"thanks"のアドレスを表示している。
メモリマップの下の段に格納されている値であり、
意味するところは上の段のアドレスだ。

3行目は、*str、つまり"thanks"が記録されている場所に入っている中身、
つまり文字そのものを表示しようとしている。
こんどはポインタじゃないので、%xで16進数で表示させている。
結果は0x74、10進数でいえば116。文字tの文字コードが0x74だ。

これで演算子の`&`と`*`の使い方はわかったかな。

>「わかったかと言われると微妙ですけど、アドレスをメモリに書いて、
> それを使って辿っていく・・・というやり方のイメージは持てました」

うん。それでいい。つまり、C言語ではメモリのアドレス、
つまり物理的な位置をリアルな数字として
変数に保存してしまうんだ。
そして、さらにその数字を書き換えてしまうことも出来る。

>「えっ？どこを指してるかわからなくなっちゃいますよ」

そうだ。すごく気をつけて書き換える必要はあるけど、出来ちゃうんだな。
プログラムを先に進んでみよう。

```c
  str = str + 4;
```

> 「あー、ホントだ。数字足しちゃってる。えええ・・・。
> これ別に好きな数字足しちゃってもいいんですか？」

別にいいよ。

ただ、その結果のアドレスが指している先のメモリが
何に使われているのか、
はたまた何にも使われていないのかは通常、
さっぱりわからないわけだから、ただ闇雲に数字を足しても意味は無い。
けど、 足そうが引こうがプログラムとしてはエラーにならない。
ここでは4を足している。するとどうなるか。
その下で確認をしているね。

```c
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
```

strの中身が+4されている。そして、その数字をアドレスとして
メモリを参照する、つまり`*str`してその値を表示すると0x6bになっている。

>「足したのに減っちゃいました？」

何を言っているんだよ。4つ右隣のメモリを見たら0x6b、つまり、
kの文字コードが入っているというわけだ。
"thanks"のtから見て、4つ隣はkだろう？

> 「おー、そういうことか。"thanks"という文字列は、
> メモリ上に隙間無く順番に書き込まれているからですね」

そういうことだ。ただし、ポインタに対する演算は
単にアドレスに数字を足すこととはちょっと違う。
ちょっと違うけど、今は似たようなものだと思っていてもいい。

ともかく、まずはC言語で何かデータを扱う時には
それがメモリ上に書き込まれているし、
そのアドレスも取り出すことが出来るということが実感できればいい。
さらに、アドレスは所詮ただの数字なので好きな数字を指定すれば、
メモリ上のどこでも参照することが出来るということもわかったかな。
これは他のプログラミング言語の体験とはまるっきり違うんじゃないか？

>「そうですね。もの凄く具体的です。64ビットの整数は
>値が大きすぎてイメージ出来ませんが、数字は数字ですもんね」

そうだ。

もっとも、私がパソコンを触りはじめた90年代前半は、
CPUこそ32bitが当たり前になっていたが、OSは16bitのものが多かった。
せっかくの32bit CPUを互換機能を使って「速い16bit CPU」として使っている
状態だったんだ。16bitのアドレスしか使えないと、
使えるメモリは64KBにしかならない。

>「すくなっ！」

64KBのメモリなら、根性があればメモリを端から端まで
プリントアウトして眺めることも不可能じゃない。
昔のプログラマにとって、メモリのアドレスと
そのアドレスに書き込まれている値というは、
普通に手に取って把握できるものだったんだ。
アドレスも16進で書いてたった4桁だし。

実際にはいわゆるIBM PC/AT互換機が使っていたIntelの8086という
16bit CPUは20ビットのアドレスバスを持っていた。
従って、64KBの16倍の1MBの広大なメモリを使用できた。

>「すくなっ！！」

お、おう・・・。まあ、そうだよね。

しかし、8086もポインタは16ビットだから、
メモリ全体にアクセスするためにはポインタを2つ組み合わせて
使う必要があった^[それぞれセグメントアドレス、オフセットアドレスと呼ぶ]。
これがとてもめんどくさかったんだけど、
21世紀にそんな話しても仕方が無いから、これ以上は触れないことにするよ。

## データ変換とキャスト

さて、C言語では実際にメモリ上に書かれた0と1のデータそのものを
強くイメージしてプログラムできるということはわかったと思う。

もうひとつ、実例で試して見ようか。
浮動小数点型がどのようにメモリ内に格納されているか確認してみよう。

```c
#include <stdio.h>
#include <math.h>

int main(int argc, char **argv){
  float pi = M_PI;

  printf("pi = %f\n", pi);
  printf("size of float = %lu\n", sizeof(pi));

  unsigned char *p = &pi;

  for(int i = 0; i < sizeof(pi); i++){
    printf("|%02x| ", *(p + i));
  }
}
```

実行結果はこうなる。

~~~
pi = 3.141593
size of float = 4
|db| |0f| |49| |40|
~~~

浮動小数点型であるfloat型の変数piを作って、
定数M_PIを代入している。この定数はC言語であらかじめ持っているものだ。

実行結果の1行目はpiに入っている値を確認している。見慣れた円周率だね。
次の行はpiのサイズを表示している。floatは4バイトという意味だ。
そして、piのポインタをunsigned char型(符号なし1バイト整数型)の
ポインタに代入している。
fload型のポインタをunsigned char型のポインタに
代入することは普通あり得ないので、コンパイラは警告を出すけど、
エラーにはならない。C言語らしいと言えるだろう。

そして、unsigned char型のポインタを1つずつ動かして、
メモリ上に書かれている値を1バイトずつ4つ読み出している。

> 「ここまでは文字列でやったのと同じですよね？」

そうだね。そして、ポインタ型がメモリに書かれたときに
確認したのと同じように、ここでメモリに書かれている内容も、
逆向きに書かれてる。

なので、浮動小数点3.1415・・・は
0x40490fdbというビット配列で表現されていることがわかる。
他の言語で浮動小数点型のメモリ上の表現をプログラムで読み出すことが
出来ないわけではない。
が、C言語のようにこんな単純なコードで読めることはないだろう。
なぜなら、そもそも浮動小数点がメモリ上でどう表現されているかなんて
知る必要がないからだ。

C言語の規格には、浮動小数点がどのようにメモリ上で表現されるかを
決めた部分はない。
つまり、これから確認する浮動小数点の表現は
私が使っているコンピュータでは
たまたまこうなっているということに過ぎない。
だから、それに依存したコードを書くことは行儀の悪いことだし、
プログラムのクラッシュに繋がる危ないことで、やるべきではない。
だから、他の言語ではわざとやりにくくしてあるんだ。

しかし、C言語ではそれが簡単にできる。
そんな危ないことをするための言語がC言語なんだ。
でも・・・、面白いだろう？

> 「はい。なんというか、機械の裏のパネルを開けたような気になります」

いいね。こういう中の仕組みを知っていることが役に立つこともあるし、
何より、面白い。

では、0x40490fdbがなんで3.141592・・・になるかを説明しておこうか。

今から説明するのはIEEE754という規格で定義された
単精度浮動小数点数の仕組みだ。大抵のC言語の実装では
この規格に沿った浮動小数点を使っているらしい。

そもそも浮動小数点というのは、少数を3つのパートにわけて
保存するやり方だ。

~~~
-123.456 => (-1) × (1.23456) × 10^(2)
~~~

小数を上のように、(1)符号 (2)仮数 (3)指数 の3つにわけて
それぞれ(1)1ビット (2)23ビット (3)8ビットを割り当てる。
ただし、2進数の小数だけどな。
メモリ上の順番は符号-指数-仮数の順番だ。

だから、0x40490fdb = 0100_0000_0100_1001_0000_1111_1101_1011 (_は読みやすさのために付けたもので、ないものとして解釈して欲しい)は

* 符号部:0
* 指数部:1000_0000
* 仮数部:1001_0010_0001_1111_1011_001

となる。

符号部は0ならプラス、1ならマイナスだ。
指数部は「符号なし整数としてみて1から254の値で、-126から127までを表す」ものとする

> 「え？ナンですって？」

浮動小数点はもの凄く小さい数字も、もの凄く大きい数字も扱うから、
指数はプラスにもマイナスにもなるだろう？

どうして素直に符号付き8ビット整数じゃないのかといえば、
0x00と0xffが指定されたら、それぞれゼロと無限大を指すことに決めてるからだ。
その両端を抜いた254個の値に値を割り振ったので、
普通の符号付き整数のように2の補数表現を使っていないんだね。
2の補数がどんなのかは大丈夫だよな？

>「えとー、うっすらと記憶が・・・確認しておきます」

ま、要するに指数部は符号なし整数として読んで、-127すればいい。
10000000は符号なし整数なら128だから、-127して1。
つまり、小数点は右に1つ動くということになる。

次に仮数部だが、23ビットの先頭に1を補い、それを整数部として、
もともとあった23ビットが全部小数部として読む。
つまり、1.10010010・・・ということだ。

2進数の小数の読み方は大丈夫かな。
例えば1.101は10進数に直すと1+(1/2)+(1/8)=1.625になるよ。

さて、指数部が1だったので小数点は1つ右に動く。だから
11.001001・・・ということになるかな。
2+1+(1/8)+(1/64)+・・・なので、だいたい3.1ぐらいになりそうだね。
計算して確かめてくれ。

しかし、もちろん0x40490fdbは1078530011という整数を表すこともある。
メモリに書いてあるバイト列をどう解釈するかはプログラム次第だ。
プログラム言語の特徴をいうときに、型ありとか型なしとか、
動的型付けとか静的型付けとかいう。
C言語はもちろん型があって、静的な型付けの言語だ。
しかし、それは変数の型の話だ。

Javaは変数に型があり、Rubyは変数に型がない。
しかしどちらの言語でも、オブジェクトには型がある。
オブジェクトは自分自身が何の型を表現しているデータか知っている。
Javaのオブジェクトだってメモリ上のどこかにかいてあることは
変わらないはずだ。しかし、Javaのオブジェクトはそのデータの中に
自分自身がどんな型のオブジェクトかを示す情報を持っているということだ。

しかし、C言語ではオブジェクトには型がない。
C言語のオブジェクトはメモリ上に書かれたバイト列そのもので、
それをどう解釈するかはプログラムに任されている。
解釈はそのオブジェクトがどんな型の変数に入っているかに依存する。

```c
float pi = M_PI;
```

こう書いた瞬間、piに格納された0x40490fdbは円周率を表す少数だ。
しかし、これをなんとかして、int型の変数に格納してしまえば、
それはもう1078530011という整数として扱われてしまう。

試して見よう。

```c
#include <stdio.h>
#include <math.h>

int main(int argc, char **argv){
  float pi = M_PI;

  int i = pi;

  printf("pi = %f\n", pi);
  printf("i = %d\n", i);

  i = *((int*)&pi);
  printf("i = %d\n", i);
}
```


実行結果はこうなる。

~~~
pi = 3.141593
i = 3
i = 1078530011
~~~

int型のiにfloat型のpiを代入すると、C言語は
「少数を整数にいれるんだな」と解釈してくれる。
その結果、3.14・・・の整数部である3がiに入る。

しかし、

```c
i = *((int*)&pi);
```

とすると、piに入っているメモリの状態がそのままiに入る。

> 「括弧と記号ばかりで、目が滑ります・・・」

何をしているのか確認してみよう。

|表記|型|説明|
|-|-|-|
|`pi`|float型|変数piが確保しているメモリ領域に入っている値そのもの|
|`&pi`|float型のポインタ|変数piが確保しているメモリ領域のアドレス|
|`(int*)&pi`|int型のポインタ|変数piが確保しているメモリ領域のアドレスをint型のポインタと解釈|
|`*((int*)&pi)`|int型|変数piが確保しているメモリ領域のアドレスをint型のポインタと解釈して値を取り出す|

この`(int*)`のように、括弧付きの型名を式に付けることにより、型変換をすることが出来る。
これをキャストという。
例えば、キャストを使って、整数型と浮動小数点型の間の変換を行うことも出来る。
むしろ、普通にキャストというとこっちをイメージするかも知れない。
先ほど、

```c
int i = pi;
```

の部分で暗黙の型変換が行われて、3.14が3になっていた。
これは実際には

```c
int i = (int)pi;
```

が行われていたということだ。さっきも見たとおり、
浮動小数点型の3.14と整数型の3は内部的にはまったく違う形式だ。
だから、`(int)3.14`をするとC言語はいくらかの計算をして3を導いている。

しかし、ポインタのキャストは意味が違う。
`(int*)&pi`してもC言語はなんの計算もしない。
ただ、そのポインタに格納されているアドレスから値を読み出すときに、
そこにあるバイト列をどう解釈するかが変わるだけだ。
だって、int型のポインタだろうが、floatのポインタだろうが、
ポインタはただのアドレスだからだ。

キャスト次第でメモリ上の0と1の並びをどう解釈するかを
C言語は簡単に変更できる。
これがC言語がコンピューターを機械として扱うのが得意ということの1つの面だね。


## 共用体

(これからかく)
