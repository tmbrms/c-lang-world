# 変数は型あり。データは型なし。

## 表の顔と裏のバイト列

>「でも、0と1の羅列ってイメージが難しいですね」

そうだね。だから、Cプログラマは実際には数字をまとめて扱う。
Cプログラマの頭の中には0と1があるのではなく、
方眼紙のひとマスひとマスに、0から255までの数字がはいっているところが
イメージされている。0から255まで数字は8ビット、つまり0か1の8桁で
表される。0から255の数字は16進数で書けば2桁だから、こんな感じだ

![メモリのイメージ](./memory_map.png)

実際には0101010と0と1が並んでいるんだけども、
それを人間の方で勝手に8つずつに区切っているわけだ。
まあ慣れたプログラマなら16進数を2進数に直すのはすぐだし。
全部覚えちゃってるからね。

>「え！？256種類全部覚えているんですか？」

いや、覚えるのは16こでいいじゃない。出てくる文字は0からfまでの16個なんだから。

>「あ、そうか。それでも覚えるのは大変じゃないですか？」

別に覚えなくてもいいよ。すぐに求められるんだから。
例えば、b(2進数の11)だったら8 * 1 + 4 * 0 + 2 * 1 + 1 * 1 = 1011は
すぐに求められるだろう？
だったら0x6bが01101011なのもすぐわかるだろう。逆にこれが10進数でいくつかと
聞かれると6 * 16 + 11 は暗算が難しいよね。
なので、10進数はメモリを表現するのにはあんまり使わない。

そして、実はC言語もこの8ビットの単位ごとの箱に番号をつけて、
それをアドレスとして使う。
というのも、メモリは1ビットずつ読むわけではなくて、
ある程度まとめて読むからだ。ご想像の通り、32bit CPUは32ビットずつ読む。
で、8ビットより細かい単位で読むマシンの事は考えなくてもよかろうと
C言語を作った時点でなったんだろうね。あまりよく知らないけど。

というわけで、この8ビット単位の箱に番号つまりアドレスを扱うんだ。

では、実際にメモリのアドレスを見てみよう。
次のプログラムをコンパイルして、実行してみよう。

```c
#include <stdio.h>

int main(int argc, char** argv){
  char *str = "thanks";
  
  printf("ADDRESS: %p\n", &str);
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);

  str = str + 4;

  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
}
```

実行結果はこんな感じだ

~~~
ADDRESS: 0x7ffeea072a58
ADDRESS: 0x105b8df92
VALUE: 74
ADDRESS: 0x105b8df96
VALUE: 6b
~~~

>「うわっ！なんじゃこりゃ！」

なんのことかさっぱりわからないと思うけど、
C言語でやれることの雰囲気が味わえれば良いから。

先に、メモリマップを出しておこうか。
このプログラムを実行すると、メモリの内容はこんな感じになっている。

![メモリマップ](./address.png)

メモリの2カ所のアドレスが表示されてる。
1つは0x105b8df92付近。もうひとつは0x7ffeea072a58付近。
両者はかなり桁が違うので、メモリ上のかなり離れた位置にあると言うことがわかる。

> 「このアドレスの値は、たまたまこの値なだけで
> 私のPCで実行したら変わっちゃうんですよね？」

その通り。というか、何度も実行したらそのたびに違うかも知れない。
そういうものだ。

さて、順番に見ていこうか。

まず、C言語特有の演算子から行こう。いきなりポインタの話だ。

2つの演算子が登場する。1つは`&`。もうひとつは`*`だ。
`&`を「アドレス演算子」、`*`を「間接演算子」と呼ぶよ。

`&`を変数に付けると、その変数のメモリ上の位置、つまりアドレスが
取得できる。`*`はその逆演算だ。変数に`*`を付けるとその変数の値を
アドレスだとみて、そのアドレスが指す位置に格納されているデータを取り出す。
これは実例を見ればさほどややこしくはないと思う。

もうひとつ、アドレスを格納する変数を宣言するときにも`*`を使う。
こっちがなかなかややこしい。
さっきのコードの最初の部分を見てみよう。

```c
char *str = "thanks";
```

これは何をやっているのかというと、「char型のポインタstrを宣言して、
そこに文字列のアドレスを格納している」という言い方になる。
いよいよポインタという言葉がでてきたね。
つまり、ポインタとは「アドレスを格納するため変数」だ。

では、char型のポインタとはどういう意味だろう。

char型というのは、(英数字)1文字を格納するための整数型だ。
英語圏の人はたかだかアルファベットと数字といくつかの記号しか
文字が必要じゃなかったので、1文字を8ビットの整数で表すことにした。
日本語のことなんか、これっぽっちも考えてなかった時代に作られてるからね。

char型の変数に`&`をつけると、アドレスが得られる。
私のPCは64bitなので、実体は8バイトの整数だ。
同じように、int型の変数に`&`をつけても、同じように8バイトの整数として
アドレスが得られる。

そのアドレスに対して`*`を適用して、元の値を取り出すときに
もともとchar型だったのか、int型だったのかわからないと困ってしまう。
charなら8バイトの箱1つ読めばいいが、intなら32ビットだから4つ読まないといけない。
だから、ポインタはもともとどんな型のデータのアドレスだったかを
維持しておく必要がある。
だから、「char型のポインタ」というものが必要になるんだ。

そして、宣言の書き方なんだけど、`char *str`と書いて、
「strは`*`を付けるとcharになる変数」という意味になる。
つまり、`str`はchar型のポインタということだ。
けして、「`*str`」という変数を宣言しようとしているわけではない。
回りくどいね。

さらにややこしいことに、`char* str`と書くことも出来る。
これだと`char*`で「char型のポインタ」という型の様に見えるので、
こっちを好む人も多い。
実は`char * str`でもエラーにならないんだけど、これだと
掛け算みたいで訳がわからないので、こう書く人は見たことがない。

> 「え、どっちでもいいんですか？」

最初に書いた`char *str`の書き方をオススメしておくよ。
ただ、`char* str`と書くのも多く見かけるので、驚かないように。

さて、

```c
char *str = "thanks";
```

と書かれた1行に対して、C言語は何を行うのか見ていこう。

まず、メモリ内に"thanks"という文字列に当たるバイト列を
書き込む。代入の右側に文字列リテラルを書くと、
その文字列を書き込んだメモリのアドレスが代入の左側に渡る。

次に、そのアドレスを格納するための変数strのために
メモリを確保する。アドレスは8バイトだからメモリのどこかに
8バイトの空きを見つけて、そこを「ここはstrが使うからね」と
メモっておく。そして、そこに"thanks"が書かれた場所のアドレスを
保存する。

これで、さっき見せたメモリの状態になるんだ。
1行で結構いろいろとやったもんだ。

プログラムの次の部分を見ていこう。

```c
  printf("ADDRESS: %p\n", &str);
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
```

printfは、変数をいろんなフォーマットで表示する関数で、
C言語の一番最初のページに書いてあるような関数だけど、
実はものすごく奥が深い関数だ。ま、おいおい知ってくれたらいい。

%pを指定すると、2つ目の引数をポインタだと解釈して、
16進数表示してくれる。
最初は&str、つまり"thanks"のアドレスを保存しているポインタのアドレスを
表示している。
そして、次にstr、つまり"thanks"のアドレスを表示している。
3行目は、*str、つまり"thanks"が記録されている場所に入っている中身、
つまり文字そのものを表示しようとしている。
こんどはポインタじゃないので、%xで16進数で表示させている。
結果は0x74、10進数でいえば116。文字tの文字コードが0x74だ。

これで演算子の`&`と`*`の使い方はわかったかな。

>「わかったかと言われると微妙ですけど、アドレスをメモリに書いて、
> それを使って辿っていく・・・というやり方のイメージは持てました」

うん。それでいい。つまり、C言語ではメモリの位置をリアルな数字として
変数に保存してしまうんだ。そして、さらにその数字を書き換えてしまうことも出来る。

>「えっ？どこを指してるかわからなくなっちゃいますよ」

そうだ。すごく気をつけて書き換える必要はあるけど、出来ちゃうんだな。
プログラムを先に進んでみよう。

```c
  str = str + 4;
```

> 「あー、ホントだ。数字足しちゃってる。えええ・・・。
> これ別に好きな数字足しちゃってもいいんですか？」

別にいいよ。ただ、その結果のアドレスが指している先のメモリが
何に使われているのか、
はたまた何にも使われていないのかはさっぱりわからないから意味はない。
けど、 足そうが引こうがプログラムとしてはエラーにならない。
ここでは4を足している。するとどうなるか。
その下で確認をしているね。

```c
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);
```

strの中身が+4されている。そして、その数字をアドレスとして
メモリを参照する、つまり`*str`してその値を表示すると0x6bになっている。

>「足したのに減っちゃいました」

何を言っているんだよ。4つ右隣のメモリを見たら0x6b、つまり、
kの文字コードが入っているというわけだ。
"thanks"のtから見て、4つ隣はkだろう？

> 「おー、そういうことか。つまり"thanks"という文字列は、
> メモリ上に隙間無く順番に書き込まれていたってことですね」

そういうことだ。ただし、ポインタに対する演算は
単にアドレスに数字を足すこととはちょっと違う。
ちょっと違うけど、今は似たようなものだと思っていてもいい。

ともかく、まずはC言語で何かデータを扱う時には
それがメモリ上に書き込まれているし、
そのアドレスも取り出すことが出来るということが実感できればいい。

さらに、アドレスは所詮ただの数字なので好きな数字を指定すれば、
メモリ上のどこでも参照することが出来るということもわかったかな。
これは他のプログラミング言語の体験とはまるっきり違うんじゃないか？

>「そうですね。もの凄く具体的です。64ビットの整数は
>値が大きすぎてイメージ出来ませんが、数字は数字ですもんね」

そうだ。

もっとも、私がコンピューターを触りはじめた90年代前半は、
CPUこそ32bitが当たり前になっていたが、OSは16bitのものが多かった。
せっかくの32bit CPUを互換機能を使って「速い16bit CPU」として使っている
状態だったんだ。だから、使えるメモリは64KBしか無かった。

>「すくなっ！」

これだと、根性があればメモリを端から端までプリントアウトして眺めることも
不可能じゃない。昔のプログラマにとって、メモリのアドレスと
そのアドレスに書き込まれている値というは、
普通に手に取って把握できるものだったんだ。
アドレスも16進で書いてたった4桁だしね。

## データ変換とキャスト

(これからかく)

## 共用体

(これからかく)
