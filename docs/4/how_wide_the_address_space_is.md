# この広いアドレス空間いっぱい

## 32bitポインタ

今ではすっかりPCは64bitになったけど、
1995年にWindows95の登場したときが
世の中に32bitのCPUと32bitのOSが普及したタイミングだった。
前も説明した通り、それまでの16bitのアドレスではメモリ64KBしか
1度に扱うことが出来ない。これは少し大きなデータ、例えば
ちょっとしたグラフィックなどを扱う上でも不便極まりない。

例えば、32×32の大きさのグラフィック、例えばアイコンのデータって
どのぐらいになる？

> 「えーっと、32×32だから、ピクセル数は2^5^×2^5^=2^10^。
> 1ピクセルに16色使うとするとピクセルごとに2^4^必要だから、
> 2^14^です」

うん。いわゆるウェブブラウザのタブにくっついてるアイコン、
あれをfaviconっていうけど、あのアイコンの大きさがそのぐらい。
16bitだと、アレが4つでいっぱいになっちゃう量のメモリしか
1つのポインタでは使えないってことだ。

しかし、32bitあれば4GBのメモリを扱える。
これだけのメモリを扱えれば、プログラムを書く上であまり困る事がない。
整数型も約7万までしか扱えない16bitの整数では、
上限にぶつからないか頻繁に気にする必要があったけど、
32bitの整数が使えればほとんど気にしなくて良いことが多い。

コンピューターが32bit環境で十分な速度で動くようになったことで、
32bitのintと32bitのポインタを気軽に使えるようになった。
プログラムが簡単になったし、やれることも一気に増えた。
それがWindows95ブームの実態だったし、 インターネット時代の布石でもあったんだ。

> 「はー、ポインタの大きさがそんなことに関わっていたとは知りませんでした。
> でも、Windowsってそんな昔からあったんですねー」

ぐはっ、いや、その前にWindows3.1というのが・・・まあいいか。
それに比べて32bitから64bitへの変化は緩やかだった。
もちろんコンピュータが搭載するメモリは4GBを遙かに超えたし、
4GBを越える巨大なデータを扱う必要があるプログラムの需要もたくさんある。
ただ、普通に私たちが日常的に使うプログラムの範囲では、
`sizeof(int*)`が8バイトを返す様になっても、それほど変わらなかったんだ。

> 「そうですね。私のPCのメモリは4GBしかないから、32bitのポインタでも
> 端から端まで読み放題です。PCで使っているデータが全部読めちゃうってことですよね」

そんなわけはないよね。

> 「えっ？」

## プロテクトモード

君が使っているそのPCではいろんなプログラムが動いているよね？

> 「そうですね。Webブラウザだけでも5種類ぐらい動いてます。

そうなんだ・・・なんでだろう。まあいいか。

じゃあ、FirefoxとChromeが動いているとしよう。
Firefoxでオンラインバンキングを表示させているとして、
Chromeはその画面の情報を知ることができるだろうか。

>「それはマズいですね。もしそんなことができたらセキュリティホールじゃないですか」

その通りだ。しかし、ChromeはたぶんC/C++で作られている。
Chromeのソースコードの中で、ポインタを0から順に大きくしていったら、
メモリ上のどこにだって観られると思わないかい？
そのどこかには君の口座番号が必ず入っているはずだよ。

>「ホントだ！ヤバいじゃないですか。オンラインバンキングを使うときは
> 他のブラウザは全部落とすことにします。親にも注意しておこう」

電話をしまいなさい。だからそんなわけはないんだって。

実は、インテルの32bitCPUでは、プログラムがポインタを端から端まで
スキャンしても、他のプログラムが使っているメモリは見えないようになっている。
これまで、ポインタのアドレスは物理的なメモリのアドレスそのものだと
説明してきたけど、実は32bitCPUより後ではそれは事実じゃない。

> 「えっ！騙されてたんですか？」

説明してなかっただけだ。今から説明するんで騙してないぞ。

インテルの32bitCPUにはプロテクトモードという動作モードがある。
これは、CPUで実行するプログラムごとに独自のアドレス空間を割り当てる機能だ。

> 「アドレス空間って何ですか？」

アドレス空間というのは、自分だけが使う架空のメモリアドレスみたいなものだ。
というか、プロテクトモードでは自分のアドレス空間を使ってしか
メモリにアクセスできない。

例えば、Aというプログラムのアドレス空間の0x0001番地は、実際のメモリの0x1001番地。
Bというプログラムの0x0001番地は、実際のメモリの0x2001番地、みたいな感じで
自分独自のメモリアドレスを持っているんだ。

> 「ということは、Aで0x1001番地を参照するのと、
> Bで0x0001番地を参照するのは同じってことですかね」

ところがそうじゃない。実際のメモリの0x2001番地は、Aというプログラムの
アドレス空間のどこにも割り当てられていない。Aで0x1001番地にアクセスすると、
実メモリのまた違う場所になっている。

このようにプログラムが持っているアドレス空間と実際のメモリアドレスの
対応表をコントロールして、プログラムの間でメモリをうっかり見たり、書き換えたり
できなくした。これがプロテクトモードだ。

大事なことは、この機能はCPUの、つまりハードウェアの機能だということ。
もちろん、同じ機能をOSがソフトウェアで実装することも出来たんだけど、
OSとそのコントロール下で動いているプログラムに同等の能力があると、
悪意のあるプログラムが他のプログラムのメモリを参照することは止められない。
だから、この機能がハードウェアで実装されていることはとても大事だ。
プロテクトモードでは、普通のプログラムとOSは別の権限で動いている。
普通のプログラムはどんなに頑張っても、つまりポインタを端から端までいじくっても、
決して他のプログラムを壊すことは出来ない。安心して欲しい。

逆に、プロテクトモードや他のメモリ保護機能がない環境でC言語のプログラムを
書くときには、ポインタ操作を間違えると本気で何もかも壊してしまえるので、
もの凄く気をつけなくてはならない。

もうひとつ、プロテクトモードには利点がある。仮想記憶って聞いたことがあるかい？
イマドキはもうメモリも大きいからスワップファイルを作らないことも多いけど・・・。

> 「あー、小さい頃お母さんがイライラしながら『スワッピングが、スワッピングが』
> って言ってた、あれのことかな？」

それであることを祈ろう。子供の前で言うんだから、たぶんそうだろう。

32bitアドレスでは4GBのメモリを扱える。ただし、そんなに大きな物理メモリが
使えるようになったのは最近で、32bitCPUが使われ出した頃のメモリは
数MBから数十MB程度だった。プログラムのアドレス空間にメモリを割り当てようにも、
実メモリは全然足りない。

しかし、別に4GBのアドレス空間の全部に実メモリが対応している必要はない。
プログラムで使っているのはそのごく一部だから、そこにだけ実メモリが
割り当てられていれば十分だ。

さらに、OSによって、アクティブなプログラムが切り替えられて
別のプログラムが動いているときには、割り当てられているメモリはどうせ使われない。
そうであれば、その瞬間は実メモリは取り上げられてしまっても構わないわけだ。
データが消えてしまっては困るので、プログラムが切り替えられるときに
メモリの内容をディスクに書き出して、そのメモリを他のプログラムが使う。
また、プログラムがアクティブになった時には別のメモリがアドレスに割り当てられ、
ディスクに待避していたデータが書き込まれた状態になってプログラムが再開する。

このようにして、プログラムが使っていると思っているメモリ量を
実メモリよりも遙かに大きくすることができる。これが仮想記憶だ。
プログラムのアドレス空間と実メモリが切り離された事によって
少ないメモリで大きなデータを扱うことが出来るようになったんだ。

ただし、当然のことながらプログラムを切り替えただけでディスクへの
アクセスが発生するのでパフォーマンスが落ちる。
メモリ上のデータをディスクに書き出すことをスワップアウトと呼ぶけど、
プログラムをたくさん動かしてメモリが足りなくなり、スワップアウトが
発生し出すと急激にマシン全体のパフォーマンスが低下するなんてことが
ちょっと前までのPCではよく見られた。
今ではメモリも安くなったし、ディスクもSSDになったのであまり
話題にもならなくなったけどね。

## セグメンテーションフォルト

じゃあ、実際に今の環境でポインタを操作してメモリにアクセスすると
どうなるのか試して見よう。

前の章で動かしたプログラムをもう一度見てみるよ。

```c
#include <stdio.h>

int main(int argc, char** argv){
  char *str = "thanks";
  
  printf("ADDRESS: %p\n", &str);
  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);

  str = str + 4;

  printf("ADDRESS: %p\n", str);
  printf("VALUE: %x\n", *str);

  char *c = &str;
  for(int i = 0; i < 8; i++){
    printf("VALUE: %x\n", *c);
    c++;
  }

}
```

この途中でポインタに整数の4を足しているけど、全然違う値を入れるとどうなるだろう。
試しに

```c
str = str + 1000000000004;
```

に書き直して、実行してみよう。

~~~
ADDRESS: 0x7ffee1523a48
ADDRESS: 0x10e6dcf96
VALUE: 74
ADDRESS: 0xe9e312df9a
Segmentation fault: 11
~~~

> 「Segmentation fault？」

詳細は割愛するけども、セグメントというのはメモリ上の区画の事で、
プロテクトモードでアドレス空間と実メモリのマッピングが
行われる単位のことだと思って欲しい。
「セグメンテーション・フォルト」は、マッピングが存在しない、つまり、
触ってはいけない区画に触りましたよ、ということで怒られている。
セグメンテーション・フォルトが表示されたときは、大抵、ポインタのアクセスに
失敗している。アドレスじゃないものをアドレスとして扱ってしまったりだ。
C言語でC言語らしいプログラムを書いているとしょっちゅう遭遇するだろうから
覚えておこう。

また、ポインタ操作を間違ったからといって、
必ずセグメンテーション・フォルトになるというものでもない。
ポインタに4を足すのも1000000000004を足すのも本質的に差はない。
片方は「たまたま」意味のあるメモリ領域を参照したというだけだ。
1000000000004を足した先が、たまたま意味のあるメモリ領域で、
値が返ってくる可能性はある。過信してはいけない。

プロテクトモードも過信は禁物だ。
プログラムのバグで他のプログラムに影響することは無くなったが、
依然として「自分自身を書き換える」ような危険なプログラムは可能だ。
C言語は機械としてのコンピュータを自在に操れる。
だからこそ、機械のレベルでプログラムの異常から他のプログラムを
守ってくれるのがプロテクトモードであり、その結果表示されるのが
セグメンテーション・フォルトだ。
これでだいたい、C言語でプログラムを書くときに意識しなければいけない
機械としてのコンピュータにおけるメモリとはどんなものかの話は終わりだよ。








