# C言語にとって、コンピュータとは

## Rubyにとって、コンピュータとは

> 「いよいよ世界の秘密について語られるんですね。クライマックスですね！」

いや、冒頭だよ？それもアバンタイトルだ。
C言語じゃなくて、「普通の」オブジェクト指向言語であるRubyにとって
世界はどうなっているかという話を、前置きとしよう。

ん？どうして君が得意なJavaじゃないのかって？
それは、私がRubyが好きだからというのが1番の理由だけど、
主な理由は記述が簡潔だからだ。サンプルコードは簡潔な方がいいだろう？
大丈夫。そんな難しいコードは見せないから。

さて、Rubyはオブジェクト指向言語だ。それも、かなり純粋なオブジェクト指向言語だ。
ここでいう純粋な、という意味は、世界を構成する要素がオブジェクトだけだということ。
世の中のものは全部オブジェクトで出来ていて、これはオブジェクト、これは
オブジェクトじゃない・・・と区別する必要がない。なので説明が簡単。良いことだよね。

ここに1行のRubyのコードがある。

```ruby
today = Time.now
```

何をしているかは想像がつくかな？

> 「今日は今です、かな？」

そのまま読むなよ。意味がわからないよ。
Rubyの用語で言えば、「Timeクラスのクラスメソッドnowの戻り値である
Timeクラスのインスタンスを、変数todayに格納した」かな。

> 「クラスメソッドは、Javaのstaticメソッドって事でいいんですよね？」

そう。何の変哲も無い、普通のコードだよね？
それで、このコードを見たとき、頭の中にはどんなイメージが浮かんでる？

> 「コードを実行した時刻で止まった時計が、todayって名札を貼った箱の中に入ってます」

なるほど。じゃあ、こうしたら？

```ruby
clock1 = Time.now
clock2 = clock1
```

> 「2つの箱があって、それぞれに止まった時計が入ってます」

うん、そうなりそうだけど、それは間違ったイメージだな。
ホントに時計は2つあるの？

> 「あ！そうです、違います。時計は1つです。
> clock1とclock2は同じ時計を指してます。それを間違って、バグを作って怒られました」

うん、そして怒ったのは私だ。よく覚えていたね。

Javaだとプリミティブ以外のnewでインスタンスを作るようなもの、
つまりオブジェクトはそのものが変数にはいっているんじゃない。
変数に入っているのは参照、つまりオブジェクトを「指し示しているもの」だ。
Rubyでは、ほぼすべて(Fixnum以外)はオブジェクトだから、
同じように変数にオブジェクトそのものが入っているイメージだと間違うんだ。
つまり、変数ってのは箱じゃないんだな。

こう考えてみよう。この世界は2つの異なる世界から出来ている。
現実世界と、もうひとつは霊界でもアストラルサイドでもなんでもいいけど
現実世界からは直接触れない世界だ。これをO界と呼ぶことにしよう。
現実世界の方は、N界だ。君は、N界の住人だよ。

N界の君が、`today = Time.now`と唱える。
すると、O界にはその時刻を表すTimeオブジェクトが生まれる。
そして、君の手は"today"と書かれたお札を握りしめている。

君はそのお札を通してO界のTimeオブジェクトにメッセージを送ることができる。
別のお札を用意して、それと"today"と繋がってるTimeオブジェクトとを
新たに繋げることもできる。変数同士の代入って、そういうことだね。
そして、Javaだとお札には種類があって、特定のタイプのオブジェクトとだけ
繋げることが出来るけど、Rubyのお札は1種類だ。どんなオプジェクトとでも
繋げることが出来る。これをプログラミングの用語で言えば、「静的型と動的型」だ。

> 「え？えーっと、お札って変数のことだから、変数に種類があって、オブジェクトのタイプ・・・
> 本当だ。typeってそのまま型を英語で言っただけじゃないですか！」

そういうこと。じゃあ、お札を使って、オブジェクトにメッセージを送ってみよう。

```ruby
today = Time.now
str = today.to_s
```

`to_s`はオブジェクトを文字列で表すメソッドだ。Timeは`to_s`メソッドを持ってる。
つまり、"today"というお札を通じてO界のオブジェクトに`to_s`というメッセージを
送った。オブジェクトはそれに答えて、新たに文字列、つまりStringオブジェクトを生み出す。
君はそれを"str"という新しいお札に繋げたってワケだ。

Rubyは動的型だからこういうことも出来る。

```ruby
today = Time.now
today = today.to_s
```

"today"に繋がったオブジェクトに`to_s`というメッセージを送り、
その結果新たに作られたStringオブジェクトに"today"を繋ぎ直す。

すると、以前"today"に繋がっていたTimeオブジェクトには、
もう連絡をする手段は無くなる。N界とO界を繋いでるのは、お札だけだからね。

> 「寂しんぼうのTimeオブジェクトはどうなっちゃうんですか？可哀想です！」

どうなっちゃうのか、N界の住人は知ることができない。
今でもあるのか、消えてしまったのか、わからないんだ。
消えちゃうことがあるのかって？だって、消えないとO界はオブジェクトで溢れちゃうだろう。
N界に繋がっているオブジェクトが勝手に消えると困ってしまうけど、
繋がってないオブジェクトは消えたって構わない。
無駄を省く意味でも、消した方が良いだろうね。
繋がっていないオブジェクトを探して、消す作業。
それがガベッジコレクション、略してGCだ。

> 「略してガベコレですよ。知ってます。ゴミ掃除です！」

それそれ。これがRubyにとっての世界だ。

N界、つまりNamespace(名前空間)があり、O界、つまりObjectがある。
その2つをRubyが適切に管理してくれて、それらを使って
プログラマはやりたいことをやる。実際にコンピュータの中で
CPUやメモリやハードディスクがどういう働きをしてそれらを
実現しているかは、プログラマは知らなくても良い。
コンピュータの能力が許す限り、いくらでもオブジェクトを作って構わない。
これが、Rubyにとって、あるいはRubyプログラマにとっての世界のあり方だ。

> 「すごいです。私、オブジェクト指向のオブジェクトがなんなのか、
> 漠然としか理解できなくてもやもやしていたんです。でも、
> O界にいるものがオブジェクトなんですね。わかりやすいです」

そうだね。もっとも、Javaだと何がオブジェクト、つまりO界、Javaの言葉で言うとヒープに
いるのかはそんなに単純じゃないけど、でも、この世界観に基づいて
ゆっくりJavaの教科書を読み直してみると頭の整理はされるかもね。
教科書を書いている人はこのようなイメージを持って書いているはずだから。

## コンピュータの底の底

さて、もうひとつの前置きをしよう。今度はCPUにとっての世界についてだ。
直接、CPUに命令を出すプログラマにとっての世界と言ってもいい。
機械に近いレベルを低レイヤー、抽象度が高い方を高レイヤーという
言い方をするけど、これからの話は一番下のレイヤー。コンピュータの底の底のレベルだ。
これより低いレイヤーに入ると、コンピュータの話なんだか、個々の部品の話なんだか
わからなくなってしまう。

> 「CPU？CPUはコンピュータの頭脳だって教わりましたけど、CPUにも
> 世界があるんですか?」

あるね。君が言うとおり、CPUはコンピュータで実際に計算を行うところだ。
そして、CPUにとっての世界とはメモリ、ほとんどそれだけなんだ。

CPUからはいろんな線が出てる。その一本一本に電気を流して、CPUは
コンピュータのあちこちと合図をやりとりしてる。
例えば、「今、キーボードが叩かれたよ！」とか「時間が来たよ！」とか。
でも、物理的な線でやりとりしてる相手はとても限られている。
そんな100本も200本も線で結んでるんじゃ、きりが無いからね。
それ以外の外部からの情報は全部メモリを経由して手に入れるんだ。

CPUの内部には、レジスタという小さいメモリ領域がある。
CPUがやっていることはメモリからそのレジスタにデータをコピーすること、
レジスタのデータをメモリにコピーすること、
そしてレジスターのデータを命令に従って書き換えること。
例えば、レジスタAの値にレジスタBの値を足して書き換えるとか。
基本的にはそんなものだ。

そして、どんな計算を次にするかという命令自体も、メモリから読み込む。
メモリ上に命令、つまりプログラムが書いてある。
もちろん、ここでいう命令はCPUがそれぞれ独自に持っている命令だ。
俗に機械語、Machine Languageなんて呼んだりする。

どんなCPUにもそれぞれ「こんな命令をすることが出来ます」という取扱説明書がある。
例えば、IntelのIA-32という種類のCPU、いわゆるPentiumなんて呼んでた頃のCPUが
持ってる命令の説明書は[これ](https://www.intel.co.jp/content/dam/www/public/ijkk/jp/ja/documents/developer/IA32_Arh_Dev_Man_Vol2A_i.pdf)だ。
IA-32が搭載されたパソコンを使っている人の99.99%はこの本の存在自体を知らないと思うけど、
世の中にはコレを読み込んで、CPUに命令している人達がいっぱいいるんだ。

さて、話を戻すよ。
CPUに対する命令は、メモリの上に専用の書き方で書いてある。
そして、メモリのどこから命令を読むかもCPUはレジスタの値として持っている。
それを使って指示通りに命令を1つずつ読んでいくんだ。
ループ処理のように最後まで処理をしたら最初に戻るという場合、
この「次に実行するプログラムが書いてある場所が書いてあるレジスタ」を
書き換えて、処理をループの先頭に戻す。
そうやってCPUに繰り返し処理をさせるんだね。

さて、CPUはメモリのどこかから次に実行する命令を取り出して、
またどこかから処理する対象のデータを取り出して・・・
と日がな一日やっているワケだけども、
どこかというのはどうやって指定してるんだろう。

> 「さあ・・・メモリに番号でも振ってあるんですかね？」

おっとびっくり、大正解だ。メモリには端っこから順番に番号が振ってある。

メモリというのは言ってみればONとOFFをバチバチ切り替えられるスイッチみたいなもので、
それがもの凄い数並んでる。そして、そのスイッチには0から順番に番号が振ってあって、
1つ1つ、明確に指定できる。番号を指定すればそのスイッチがONかOFFかは見ればわかるし、
自由にONとOFFを切り替えることもできる。

さて、この番号だけど、何桁ぐらいあれば足りるだろうか？
君の今使ってるパソコンのメモリはいくつだい？

> 「聞いて下さいよ。4GBしかないんですよ。8GBは基本的人権って聞きました。
> 人権侵害ですよ。UNHCRに訴えようか」

なんだい、UNHCRって？国連人権理事会？妙なことはよく知っているなあ。
それで、4GBのメモリ全部に番号を振るには何桁あればいいの？

> 「4GBはだいたい4000MB、4000MBは4,000,000KB、つまり、4,000,000,000バイトだから
> ひい、ふう、みい・・・10桁？」

どうして10進数？コンピュータなんだから数字は2進数で扱うでしょ。

> 「あ、そか。えーっと、2の10乗が1024、つまり約1000だから、4 × 2^10 × 2^10 × 2^10 なので
> 4 × 2^30です！」

4は2の何乗？

> 「しまった！2の32乗です。32桁ですね」

つまり、32bitあれば4GBのメモリすべてに番号が付けられるわけだ。

32bit CPUとか64bit CPUとかいう言葉を聞いたことあるよね。
32bit CPUって何が32bitなんだと思う？
「CPUが自然に使える数字の桁数が32bit」なんて表現をするけど、
CPUにとってメモリを読むのはもの凄く自然なことだから、
32bit CPUというと、メモリに付けている番号が32bitなのが普通だ。

だから、32bit CPUだとどんなにメモリを積んでも4GBまでしか使えないんだ。
それ以上の場所を読みたくても、番号が指定できないからね。

> 「しょぼーん・・・。私のPCが32bit CPUだともうメモリは増やせないんですね・・・」

いや、2019年に32bit CPUのパソコンを使ってるってことはないと思うよ。
存分に会社と人権問題について語ってみるといい。うまくいくといいね。

さて、このメモリについている番号のことをメモリのアドレスと呼ぶ。
日本語だと番地って呼ぶ人も多いね。メモリの何番地、みたいな感じで。

ここまででCPUの世界のお話は一段落だ。
CPUは、自分が何かするための情報はほぼすべてメモリから手に入れる。
メモリからデータ取り出すために、メモリの場所を数字で指定する。
その数字をアドレスと呼ぶということがわかればOKだ。

## ちょうど良く低レベル

> 「そういえば、C言語はどこに行ったんでしたっけ？」

それに気がついちゃったかい・・・。いや、これからがまさにC言語の話だ。
C言語誕生の瞬間について話そう。

昔々。1970年代初めの話だ。君はもちろん生まれてないし、
私も生まれてない。その頃に生まれたのが、あのUnixだ。

> 「Unixって何ですか？UbuntuとかRedHatみたいなLinuxの一種ですか？」

逆だ。LinuxがUnixの一種だよ。フィンランドの学生だったLinus Torvaldsさんが
Linuxを作るのは90年代の話だ。Unix誕生当時Linusはもう生まれてるけど
幼稚園児だね。フィンランドの幼稚園がどんなものかは知らないけども、
Unix誕生当時、Linusがまだコンピュータを触ってなかったのは確実だと思うね。

まあ、それぐらい昔の話で、その当時のコンピュータは今のものとは大分違うし、
個人で勝手に使えるようなものじゃなかったんだ。みんなで共同で使うものだったんだね。

ところが、Unixを作った人達はひょんなことから2つの大切なものを手に入れた。
1つはPDP-7という好き勝手にいじっていいコンピュータだ。
もっとも、勝手に使っていいぞとうち捨てられていたぐらいだから
当時としても大した性能じゃなかったらしい。

もうひとつは時間だ。当時、彼らがやっていたプロジェクトが頓挫した。
その頓挫したプロジェクトもOSの開発プロジェクトで、OSの名前はMulticsという。
当時としてはかなり先進的で大規模なプロジェクトで、
大規模なプロジェクトというのは頓挫しがちだというのは、今も昔も変わらない。
それでヒマになっちゃったらしい。

> 「痛いほどよくわかります。こないだまでいたプロジェクトなんてですね・・・」

待て待て。その話は今度、居酒屋で聞いてやる。先に進めるぞ。

そんなわけで、ヒマなOSづくりの専門家たちに勝手に使っていいコンピュータを与えたので、
彼らはそこで動くOSを作ってしまった。それが最初のUnixだ。
もちろん使っているコンピュータがショボいのでMulticsほど凄い機能は入れられない。
それでMultiに対して、Uniと名付けたんだそうだ。
しかし、すぐ形になってちゃんと動いたので同僚のウケは良かったらしい。

そこで、チームはいろいろ画策してもうちょっと良いコンピュータのPDP-11を手に入れた。
PDP-7用のUnixはもちろんPDP-7専用の機械語で作られていたので、
それをPDP-11用にしなくちゃいけない。
そこでチームは、Unixを機械に依らないコンピュータ言語で書き直すことにした。

オペレーションシステムは、まさにコンピュータを機械として扱うソフトウェアだ。
しかし、当時はコンピュータを機械として扱うなら機械語でプログラムし、
それを使って計算をするならFORTRANのような計算用の言語でプログラムするのが当たり前だった。
コンピュータを機械のように扱って、かつ、それがコンピュータならどんな機械でも
動くというような都合のいいプログラミング言語はなかったんだ。

そこで、Unixを作った人達はまさにOSを移植するための言語としてC言語を作り、
UnixをC言語で書き直したんだ。必要は発明の母。その後、50年以上にわたって使われ続ける
C言語が誕生した瞬間だ。ついでにいえば、Unixも同じく今でも山ほど使われている。
凄い人達もいたものだ。

> 「へぇ〜。そう考えてみると、案外昔から使われているものって多いんですね」

そうだね。コンピュータの世界は日進月歩、ドッグイヤーなんて言われて
変化の激しい世界だ。それは間違いない。
その一方で、プログラミング言語の進歩というのはそれほど速くはない。
プログラミング言語というのはコンピュータと人間が意思のやりとりをするためのものだけど、
コンピュータはともかく人間はそんなにどんどん変わるわけじゃない。
新しいプログラミング言語はどんどん出てくるけど、人間がそれを覚えて使いこなすには
時間がかかるものだからね。

さて、C言語がどういう動機で作られたかをここまでで見てきた。
では、機械に依存しないけど機械としてのコンピュータを扱うプログラミング言語というのは、
どういうものだろう。

説明したとおり、コンピュータはCPUとメモリで出来ている。
CPUはコンピュータの機種によってバラバラだ。
当然、機械語もバラバラだ。だけど、大まかな機能は変わらない。

メモリ上の2カ所に書いてある値を足して、別なところに書いて欲しいとする。
その場合、当然、CPUに「メモリをレジスタに書け」
「レジスタの値を足せ」「レジスタの値をメモリに書け」という命令を全部書く必要がある。
CPUごとに命令も違えば、どんなレジスタを持っているかも違う。
でも、大まかに言えば足し算をする機能は、どんなCPUにもある。
「足し算をしろ」というコードを書けばCPUがどんなことをするのかは
気にしなくて良いように、CPUごとの命令に書き換えてくれるプログラムがあれば便利だ。
このプログラムの事をコンパイラという。聞いたことはあるんじゃないかな。

一方、メモリの方はどんなコンピュータもあまり変わらない。
とにかくたくさんのスイッチが並んでいて、一つ一つにアドレスが付いている。
1970年のメモリもそういうものだったし、2020年のメモリもそういうものだ。
大きさが何万倍になったのかよくわからないけど、仕組みはほとんど変わらない。
なので、メモリはそのまま扱うことにした。つまり、アドレスを指定したら、
コンピュータが持っているメモリのどこにでもアクセスできるような仕組みのままにした。

これがC言語の見ている世界だ。

オブジェクト指向言語で「オブジェクト」といえば
O界に浮かぶ架空の存在だった。O界がコンピュータのなかでどういう電気信号により
実現している世界なのか、ちょっとすぐにはイメージできないと思うし、する必要もない。
しかし、C言語で「オブジェクト」といえば、メモリ上にあるデータそのものだ。
場所もはっきりわかっている。電子顕微鏡じゃないと見えないかも知れないが、
物理的にどこかはっきりと言える。どれだけの数、どういう順番で0と1が並んでいるのか
はっきりと決まっている。そこに曖昧さはない。

字面だけ見るとC言語とJava言語のコードはそんなに変わらないように見えるかも知れない。
Javaの文法がCおよびCを元にして作られたC++言語に慣れた人に親しみやすいように
決められたのだから、当然だ。しかし、プログラマが頭に思い浮かべている、
プログラムが動いているときのイメージはまったく違う。
C言語のそれは、むしろ機械語のプログラミングの方に近いと言えるだろう。

> 「面白いです！Cのプログラマの頭の中って、たくさんのスイッチが並んでるんですね。
> 今、私の中には明和電気のコイビートって楽器の巨大なバージョンみたいなのが浮かんでます」

コイビート？・・・なんじゃこりゃ。うーん、でもあながち違ってもないかな(笑)

![コイビート](https://www.maywadenki.com/cms/wp-content/uploads/NAKI-CX_Koi-beat_RGB-900x491.jpg)







